name: Sync OpenAPI Spec

on:
  # Trigger after a release is published
  release:
    types: [published]
  # Manual trigger for ad-hoc sync
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (skip pushing to API repo)'
        type: boolean
        default: false

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always

jobs:
  sync-spec:
    name: Export & Sync OpenAPI Spec
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout backend
        uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2

      - name: Install protoc
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Export OpenAPI spec
        env:
          SQLX_OFFLINE: true
          EXPORT_OPENAPI_SPEC: "1"
          EXPORT_OPENAPI_DIR: ${{ github.workspace }}
        run: |
          # Build the spec via test harness — no database or server needed
          cargo test --lib export_openapi_spec -- --ignored

          # Verify export succeeded
          python3 -c "import json; spec=json.load(open('openapi.json')); print(f'Paths: {len(spec[\"paths\"])}, Schemas: {len(spec.get(\"components\",{}).get(\"schemas\",{}))}')"

          # Convert to YAML
          pip3 -q install pyyaml
          python3 -c "
          import json, yaml
          with open('openapi.json') as f:
              spec = json.load(f)
          with open('openapi.yaml', 'w') as f:
              yaml.dump(spec, f, default_flow_style=False, sort_keys=False, allow_unicode=True, width=120)
          "

          echo "## Exported spec summary" >> $GITHUB_STEP_SUMMARY
          echo "- Paths: $(python3 -c "import json; print(len(json.load(open('openapi.json'))['paths']))")" >> $GITHUB_STEP_SUMMARY
          echo "- Schemas: $(python3 -c "import json; print(len(json.load(open('openapi.json')).get('components',{}).get('schemas',{})))")" >> $GITHUB_STEP_SUMMARY

      - name: Upload spec artifacts
        uses: actions/upload-artifact@v6
        with:
          name: openapi-spec
          path: |
            openapi.json
            openapi.yaml

      - name: Push spec to API repo
        if: ${{ !inputs.dry_run }}
        env:
          DEPLOY_KEY: ${{ secrets.API_REPO_DEPLOY_KEY }}
        run: |
          VERSION="${{ github.event.release.tag_name || 'manual' }}"

          # Set up SSH deploy key
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/api-repo-deploy
          chmod 600 ~/.ssh/api-repo-deploy
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null
          export GIT_SSH_COMMAND="ssh -i ~/.ssh/api-repo-deploy -o IdentitiesOnly=yes"

          git clone git@github.com:artifact-keeper/artifact-keeper-api.git /tmp/api-repo

          cp openapi.json /tmp/api-repo/openapi.json
          cp openapi.yaml /tmp/api-repo/openapi.yaml

          cd /tmp/api-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet; then
            echo "No spec changes detected"
          else
            git add openapi.json openapi.yaml
            git commit -m "chore: sync OpenAPI spec from backend ${VERSION}"
            git push origin main
          fi

          # Tag with the same version as the backend release.
          # This triggers the generate.yml workflow which publishes SDKs
          # with a matching version, keeping backend + SDKs in lockstep.
          if [ "$VERSION" != "manual" ]; then
            git tag "$VERSION"
            git push origin "$VERSION"
            echo "Tagged API repo with ${VERSION} — SDK generation will start automatically"
            echo "- **Tagged:** \`${VERSION}\` → SDK generation triggered" >> $GITHUB_STEP_SUMMARY
          fi

          # Clean up key
          rm -f ~/.ssh/api-repo-deploy
