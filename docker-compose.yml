services:
  # Generate self-signed TLS certificates for PostgreSQL.
  # Writes certs to the shared pg_certs volume; postgres waits for this.
  pg-certs:
    image: alpine:3.20
    container_name: artifact-keeper-pg-certs
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        if [ -f /certs/server.crt ]; then
          echo "pg-certs: certificates already exist, skipping"
          exit 0
        fi
        apk add --no-cache openssl >/dev/null 2>&1
        echo "pg-certs: generating self-signed certificates..."
        openssl genrsa -out /certs/ca.key 4096
        openssl req -x509 -new -nodes -key /certs/ca.key -sha256 -days 365 \
          -out /certs/ca.crt -subj "/CN=Artifact Keeper CA/O=Artifact Keeper/C=US"
        openssl genrsa -out /certs/server.key 2048
        openssl req -new -key /certs/server.key \
          -out /certs/server.csr -subj "/CN=postgres/O=Artifact Keeper/C=US"
        cat > /certs/server.ext <<EOF
        authorityKeyIdentifier=keyid,issuer
        basicConstraints=CA:FALSE
        keyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment
        subjectAltName=DNS:localhost,DNS:postgres,IP:127.0.0.1
        EOF
        openssl x509 -req -in /certs/server.csr -CA /certs/ca.crt -CAkey /certs/ca.key \
          -CAcreateserial -out /certs/server.crt -days 365 -sha256 -extfile /certs/server.ext
        rm -f /certs/server.csr /certs/server.ext /certs/ca.srl
        chown 70:70 /certs/server.key /certs/server.crt /certs/ca.crt
        chmod 600 /certs/server.key
        chmod 644 /certs/server.crt /certs/ca.crt
        echo "pg-certs: done"
    volumes:
      - pg_certs:/certs
    restart: "no"

  postgres:
    image: postgres:16-alpine
    container_name: artifact-keeper-db
    depends_on:
      pg-certs:
        condition: service_completed_successfully
    environment:
      POSTGRES_USER: registry
      POSTGRES_PASSWORD: registry
      POSTGRES_DB: artifact_registry
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql:ro
      - ./docker/init-pg-ssl.sh:/docker-entrypoint-initdb.d/init-pg-ssl.sh:ro
      - pg_certs:/var/lib/postgresql/certs:ro
    ports:
      - "30432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U registry -d artifact_registry"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Bootstrap Dependency-Track: change default password and extract API key.
  # Writes the key to /shared/dtrack-api-key for the backend entrypoint wrapper.
  dtrack-init:
    image: alpine:3.20
    container_name: artifact-keeper-dtrack-init
    depends_on:
      postgres:
        condition: service_healthy
      dependency-track-apiserver:
        condition: service_healthy
    volumes:
      - ./docker/init-dtrack.sh:/init-dtrack.sh:ro
      - shared_config:/shared
    entrypoint: ["/bin/sh", "-c", "apk add --no-cache curl jq >/dev/null 2>&1 && /bin/sh /init-dtrack.sh"]
    restart: "no"

  backend:
    image: ghcr.io/artifact-keeper/artifact-keeper-backend:latest
    container_name: artifact-keeper-backend
    depends_on:
      postgres:
        condition: service_healthy
      meilisearch:
        condition: service_healthy
      dtrack-init:
        condition: service_completed_successfully
    entrypoint:
      - /bin/sh
      - -c
      - |
        if [ -f /shared/dtrack-api-key ] && [ -s /shared/dtrack-api-key ]; then
          export DEPENDENCY_TRACK_API_KEY="$$(cat /shared/dtrack-api-key)"
        fi
        exec artifact-keeper
    environment:
      DATABASE_URL: postgresql://registry:registry@postgres:5432/artifact_registry?sslmode=require
      STORAGE_PATH: /data/storage
      BACKUP_PATH: /data/backups
      PLUGINS_DIR: /data/plugins
      JWT_SECRET: ${JWT_SECRET:-change-me-in-production-please}
      # ADMIN_PASSWORD: set this to skip first-boot setup lock.
      # If unset, a random password is written to /data/storage/admin.password
      # and the API is locked until the admin changes it.
      ADMIN_PASSWORD: ${ADMIN_PASSWORD:-}
      RUST_LOG: ${RUST_LOG:-info,artifact_keeper=debug}
      ENVIRONMENT: ${ENVIRONMENT:-development}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost,https://localhost}
      TRIVY_URL: http://trivy:8090
      OPENSCAP_URL: http://openscap:8091
      SCAN_WORKSPACE_PATH: /scan-workspace
      MEILISEARCH_URL: http://meilisearch:7700
      MEILISEARCH_API_KEY: ${MEILI_MASTER_KEY:-artifact-keeper-dev-key}
      # Dependency-Track integration (API key auto-provisioned by dtrack-init)
      DEPENDENCY_TRACK_URL: http://dependency-track-apiserver:8080
      DEPENDENCY_TRACK_ENABLED: ${DEPENDENCY_TRACK_ENABLED:-true}
      HOST: 0.0.0.0
      PORT: 8080
    volumes:
      - artifact_storage:/data/storage
      - backup_storage:/data/backups
      - plugins_storage:/data/plugins
      - scan_workspace:/scan-workspace
      - shared_config:/shared:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/readyz"]
      interval: 30s
      timeout: 10s
      start_period: 10s
      retries: 3
    restart: unless-stopped

  meilisearch:
    image: getmeili/meilisearch:v1.12
    container_name: artifact-keeper-meilisearch
    environment:
      MEILI_MASTER_KEY: ${MEILI_MASTER_KEY:-artifact-keeper-dev-key}
      MEILI_ENV: development
    volumes:
      - meilisearch_data:/meili_data
    ports:
      - "7700:7700"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7700/health"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  trivy:
    image: aquasec/trivy:latest
    container_name: artifact-keeper-trivy
    command: ["server", "--listen", "0.0.0.0:8090"]
    ports:
      - "8090:8090"
    volumes:
      - trivy_cache:/root/.cache/trivy
      - scan_workspace:/scan-workspace:ro
    restart: unless-stopped

  openscap:
    image: ghcr.io/artifact-keeper/artifact-keeper-openscap:latest
    container_name: artifact-keeper-openscap
    ports:
      - "8091:8091"
    volumes:
      - scan_workspace:/scan-workspace:ro
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8091/health')"]
      interval: 30s
      timeout: 5s
      retries: 3
    restart: unless-stopped

  # OWASP Dependency-Track for SBOM analysis and vulnerability tracking
  # https://dependencytrack.org/
  dependency-track-apiserver:
    image: dependencytrack/apiserver:4.11.4
    container_name: artifact-keeper-dtrack-api
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      # Database configuration (uses same Postgres, different database)
      ALPINE_DATABASE_MODE: external
      ALPINE_DATABASE_URL: jdbc:postgresql://postgres:5432/dependency_track
      ALPINE_DATABASE_DRIVER: org.postgresql.Driver
      ALPINE_DATABASE_USERNAME: registry
      ALPINE_DATABASE_PASSWORD: registry
      # API configuration
      ALPINE_DATA_DIRECTORY: /data
      # Enable API key authentication
      ALPINE_ENFORCE_AUTHENTICATION: "true"
      # Optional: Enable CORS for frontend
      ALPINE_CORS_ENABLED: "true"
      ALPINE_CORS_ALLOW_ORIGIN: "*"
      # Proxy configuration (required for NVD mirroring behind corporate proxies)
      ALPINE_HTTP_PROXY_ADDRESS: ${DTRACK_HTTP_PROXY_ADDRESS:-}
      ALPINE_HTTP_PROXY_PORT: ${DTRACK_HTTP_PROXY_PORT:-}
      ALPINE_HTTP_PROXY_USERNAME: ${DTRACK_HTTP_PROXY_USERNAME:-}
      ALPINE_HTTP_PROXY_PASSWORD: ${DTRACK_HTTP_PROXY_PASSWORD:-}
      ALPINE_NO_PROXY: ${DTRACK_NO_PROXY:-localhost,127.0.0.1}
    volumes:
      - dtrack_data:/data
    ports:
      - "8092:8080"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/api/version"]
      interval: 30s
      timeout: 10s
      start_period: 60s
      retries: 5
    restart: unless-stopped

  # Optional: Dependency-Track native frontend (for debugging/admin)
  # We integrate DT data into our own UI, but this is useful for direct access
  dependency-track-frontend:
    image: dependencytrack/frontend:4.11.4
    container_name: artifact-keeper-dtrack-frontend
    profiles:
      - dtrack-ui  # Only starts with: docker compose --profile dtrack-ui up
    depends_on:
      dependency-track-apiserver:
        condition: service_healthy
    environment:
      API_BASE_URL: http://localhost:8092
    ports:
      - "8093:8080"
    restart: unless-stopped

  web:
    image: ghcr.io/artifact-keeper/artifact-keeper-web:latest
    container_name: artifact-keeper-web
    depends_on:
      backend:
        condition: service_healthy
    environment:
      BACKEND_URL: http://backend:8080
    restart: unless-stopped

  caddy:
    image: caddy:2-alpine
    container_name: artifact-keeper-caddy
    depends_on:
      backend:
        condition: service_healthy
      web:
        condition: service_started
    environment:
      SITE_ADDRESS: ${SITE_ADDRESS:-localhost}
    ports:
      - "${HTTP_PORT:-30080}:80"
      - "${HTTPS_PORT:-30443}:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  artifact_storage:
    driver: local
  backup_storage:
    driver: local
  plugins_storage:
    driver: local
  trivy_cache:
    driver: local
  meilisearch_data:
    driver: local
  scan_workspace:
    driver: local
  caddy_data:
    driver: local
  caddy_config:
    driver: local
  dtrack_data:
    driver: local
  shared_config:
    driver: local
  pg_certs:
    driver: local

networks:
  default:
    name: artifact-keeper-network
