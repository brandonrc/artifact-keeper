---
title: "Authentication & RBAC"
description: "JWT-based authentication, role-based access control, and SSO integration"
---

Artifact Keeper provides comprehensive authentication and authorization features to secure your artifact registry.

## Authentication Methods

### JWT-Based Authentication

Artifact Keeper uses JSON Web Tokens (JWT) for stateless authentication:

- **Access tokens**: Short-lived tokens (default 15 minutes) for API requests
- **Refresh tokens**: Long-lived tokens (default 7 days) to obtain new access tokens
- Tokens are signed with HS256 using the `JWT_SECRET` environment variable

#### Login Flow

```bash
# Login to get tokens
curl -X POST https://registry.example.com/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "admin"}'

# Response includes access_token and refresh_token
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "expires_in": 900
}

# Use access token in subsequent requests
curl -H "Authorization: Bearer eyJhbGc..." \
  https://registry.example.com/api/v1/repositories
```

#### Token Refresh

```bash
# Refresh access token before expiration
curl -X POST https://registry.example.com/api/v1/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refresh_token": "eyJhbGc..."}'
```

### API Tokens

API tokens provide programmatic access without username/password:

- Scoped to specific repositories or operations
- Support expiration dates
- Can be revoked individually
- Ideal for CI/CD pipelines

```bash
# Create API token
curl -X POST https://registry.example.com/api/v1/users/me/tokens \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "CI Pipeline Token",
    "scopes": ["repository:read", "repository:write"],
    "expires_at": "2027-12-31T23:59:59Z"
  }'

# Use API token
curl -H "Authorization: Bearer $API_TOKEN" \
  https://registry.example.com/api/v1/packages
```

### Default Credentials

The system ships with default administrator credentials:

- **Username**: `admin`
- **Password**: `admin`

**Important**: You must change the default password on first login. The system will enforce this requirement.

## Role-Based Access Control (RBAC)

Artifact Keeper implements three built-in roles:

### Admin Role

Full system access including:
- User and group management
- Repository creation and deletion
- Security policy configuration
- System settings and backups
- Plugin management

### User Role

Standard user permissions:
- Upload and download artifacts (where granted)
- Create repositories (if enabled)
- View security scan results
- Manage own API tokens

### Viewer Role

Read-only access:
- Browse and download artifacts (where granted)
- View repository metadata
- View security scan results
- Cannot upload or modify data

## Repository-Level Permissions

Fine-grained permissions can be assigned at the repository level:

### Permission Types

- **Read**: Download artifacts, view metadata
- **Write**: Upload artifacts, update metadata
- **Delete**: Remove artifacts
- **Admin**: Full repository control including permissions

### Assigning Permissions

```bash
# Grant user write access to repository
curl -X POST https://registry.example.com/api/v1/permissions \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "repository_id": "repo-123",
    "user_id": "user-456",
    "permissions": ["read", "write"]
  }'

# Grant group permissions
curl -X POST https://registry.example.com/api/v1/permissions \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "repository_id": "repo-123",
    "group_id": "group-789",
    "permissions": ["read"]
  }'
```

## Groups

Organize users into groups for easier permission management:

```bash
# Create group
curl -X POST https://registry.example.com/api/v1/groups \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "developers",
    "description": "Development team"
  }'

# Add users to group
curl -X POST https://registry.example.com/api/v1/groups/group-789/members \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "user_ids": ["user-456", "user-890"]
  }'
```

## LDAP Integration

Integrate with your existing LDAP directory for centralized authentication:

### Configuration

Set these environment variables:

```bash
LDAP_URL=ldap://ldap.example.com:389
LDAP_BASE_DN=dc=example,dc=com
LDAP_BIND_DN=cn=admin,dc=example,dc=com
LDAP_BIND_PASSWORD=secret
LDAP_USER_FILTER=(uid={username})
LDAP_SYNC_INTERVAL=3600  # Sync every hour
```

### How It Works

1. User attempts login with LDAP credentials
2. Artifact Keeper binds to LDAP server
3. User DN is resolved using `LDAP_USER_FILTER`
4. Authentication is verified against LDAP
5. User is created locally if first login
6. JWT tokens are issued for API access

### Group Synchronization

LDAP groups can be mapped to Artifact Keeper groups:

```bash
LDAP_GROUP_FILTER=(memberUid={username})
LDAP_GROUP_BASE_DN=ou=groups,dc=example,dc=com
LDAP_GROUP_ATTRIBUTE=cn
```

## OIDC/SSO Integration

Support for OpenID Connect (OIDC) enables SSO with providers like:
- Okta
- Auth0
- Keycloak
- Azure AD
- Google Workspace

### Configuration

```bash
OIDC_ISSUER=https://accounts.google.com
OIDC_CLIENT_ID=your-client-id.apps.googleusercontent.com
OIDC_CLIENT_SECRET=your-client-secret
OIDC_REDIRECT_URI=https://registry.example.com/api/v1/auth/oidc/callback
OIDC_SCOPES=openid,email,profile
```

### Authorization Code Flow

1. User clicks "Login with SSO" in web UI
2. Redirected to OIDC provider
3. User authenticates with provider
4. Provider redirects back with authorization code
5. Artifact Keeper exchanges code for ID token
6. User is created/updated locally
7. JWT access and refresh tokens issued

### Claims Mapping

Map OIDC claims to user attributes:

```bash
OIDC_USERNAME_CLAIM=preferred_username
OIDC_EMAIL_CLAIM=email
OIDC_NAME_CLAIM=name
OIDC_GROUPS_CLAIM=groups
```

## SAML 2.0 SSO

Integrate with enterprise identity providers (Okta, Azure AD, ADFS, Shibboleth) using SAML 2.0.

### Configuration

SAML providers are managed via the admin API:

```bash
# Create a SAML provider
curl -X POST https://registry.example.com/api/v1/admin/sso/saml \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Okta",
    "entity_id": "https://www.okta.com/exk1234567890",
    "sso_url": "https://yourcompany.okta.com/app/artifact-keeper/sso/saml",
    "certificate": "-----BEGIN CERTIFICATE-----\nMIIC...\n-----END CERTIFICATE-----",
    "sp_entity_id": "artifact-keeper",
    "attribute_mapping": {
      "username": "NameID",
      "email": "email",
      "display_name": "displayName",
      "groups": "groups"
    }
  }'
```

Or configure via environment variables:

```bash
SAML_IDP_SSO_URL=https://yourcompany.okta.com/app/artifact-keeper/sso/saml
SAML_IDP_ISSUER=https://www.okta.com/exk1234567890
SAML_IDP_CERTIFICATE="-----BEGIN CERTIFICATE-----\nMIIC...\n-----END CERTIFICATE-----"
SAML_SP_ENTITY_ID=artifact-keeper
SAML_ACS_URL=https://registry.example.com/auth/saml/acs
SAML_SIGN_REQUESTS=false
SAML_REQUIRE_SIGNED_ASSERTIONS=true
```

### SAML Login Flow

1. User clicks "Login with SAML" in the web UI
2. Artifact Keeper generates an AuthnRequest and redirects to the IdP
3. User authenticates with the IdP
4. IdP POSTs a SAML Response to the Assertion Consumer Service (ACS)
5. Artifact Keeper validates the assertion, creates/updates the user
6. A short-lived exchange code redirects the user back to the web UI with tokens

### Attribute Mapping

Map SAML assertion attributes to user fields:

```bash
SAML_USERNAME_ATTR=NameID          # Or a custom attribute name
SAML_EMAIL_ATTR=email
SAML_DISPLAY_NAME_ATTR=displayName
SAML_GROUPS_ATTR=groups
```

### Group-to-Role Mapping

Map IdP groups to Artifact Keeper roles:

```bash
SAML_ADMIN_GROUP=ArtifactKeeper-Admins    # Members get admin role
SAML_GROUP_ROLE_MAP="Developers:developer;QA:viewer"
```

### Managing SAML Providers

```bash
# List all SAML providers
curl https://registry.example.com/api/v1/admin/sso/saml \
  -H "Authorization: Bearer $ADMIN_TOKEN"

# Enable/disable a provider
curl -X PATCH https://registry.example.com/api/v1/admin/sso/saml/{id}/toggle \
  -H "Authorization: Bearer $ADMIN_TOKEN"

# Delete a provider
curl -X DELETE https://registry.example.com/api/v1/admin/sso/saml/{id} \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

## Two-Factor Authentication (TOTP)

Artifact Keeper supports time-based one-time passwords (TOTP) for two-factor authentication, compatible with any authenticator app (Google Authenticator, Authy, 1Password, etc.).

### Enabling 2FA

#### Step 1: Generate TOTP Secret

```bash
curl -X POST https://registry.example.com/api/v1/auth/totp/setup \
  -H "Authorization: Bearer $TOKEN"
```

Response:

```json
{
  "secret": "JBSWY3DPEBLW64TMMQ======",
  "qr_code_url": "otpauth://totp/ArtifactKeeper:user@example.com?secret=JBSWY3DPEBLW64TMMQ&issuer=ArtifactKeeper"
}
```

Scan the `qr_code_url` with your authenticator app, or manually enter the `secret`.

#### Step 2: Verify and Enable

Enter a code from your authenticator to confirm setup:

```bash
curl -X POST https://registry.example.com/api/v1/auth/totp/enable \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"code": "123456"}'
```

Response includes 10 backup codes -- **save these securely**:

```json
{
  "backup_codes": [
    "AAAA-BBBB",
    "CCCC-DDDD",
    "..."
  ]
}
```

### Login with 2FA

When TOTP is enabled, the login flow adds a verification step:

```bash
# Step 1: Normal login (returns totp_required)
curl -X POST https://registry.example.com/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "user", "password": "pass"}'

# Response:
# { "totp_required": true, "totp_token": "eyJ..." }

# Step 2: Verify TOTP code
curl -X POST https://registry.example.com/api/v1/auth/totp/verify \
  -H "Content-Type: application/json" \
  -d '{"totp_token": "eyJ...", "code": "123456"}'

# Response: Normal login response with access_token and refresh_token
```

### Backup Codes

If you lose access to your authenticator app, use a backup code in place of the TOTP code. Each backup code can only be used once.

### Disabling 2FA

```bash
curl -X POST https://registry.example.com/api/v1/auth/totp/disable \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"password": "your-password", "code": "123456"}'
```

## Security Best Practices

### Strong JWT Secrets

Generate a cryptographically secure secret:

```bash
openssl rand -base64 64
```

Set in environment:

```bash
JWT_SECRET=your-generated-secret
```

### Token Expiration

Configure appropriate token lifetimes:

```bash
JWT_ACCESS_TOKEN_EXPIRY=900      # 15 minutes
JWT_REFRESH_TOKEN_EXPIRY=604800  # 7 days
```

### HTTPS Only

Always use HTTPS in production:

```bash
REQUIRE_HTTPS=true
```

### Rate Limiting

Protect against brute force attacks:

```bash
RATE_LIMIT_LOGIN=5       # Max 5 login attempts
RATE_LIMIT_WINDOW=300    # Per 5 minutes
```

### Audit Logging

Enable comprehensive audit logs:

```bash
AUDIT_LOG_ENABLED=true
AUDIT_LOG_PATH=/var/log/artifact-keeper/audit.log
```

## Troubleshooting

### Token Validation Failures

Check that `JWT_SECRET` matches across all backend instances.

### LDAP Connection Issues

Test LDAP connectivity:

```bash
ldapsearch -x -H $LDAP_URL -b $LDAP_BASE_DN -D $LDAP_BIND_DN -w $LDAP_BIND_PASSWORD
```

### OIDC Configuration

Verify redirect URI is registered with your OIDC provider and matches `OIDC_REDIRECT_URI` exactly.
